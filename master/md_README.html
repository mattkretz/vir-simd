<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vir-simd: vir::stdx::simd</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vir-simd<span id="projectnumber">&#160;0.4.189</span>
   </div>
   <div id="projectbrief">Parallelism TS 2 extensions and simd fallback implementation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_README.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">vir::stdx::simd</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md23"></a></p>
<p><a href="https://conan.io/center/recipes/vir-simd"><img src="https://img.shields.io/conan/v/vir-simd" alt="Conan Center" class="inline"/></a> <a href="https://github.com/mattkretz/vir-simd/actions/workflows/GCC.yml"><img src="https://github.com/mattkretz/vir-simd/actions/workflows/GCC.yml/badge.svg" alt="GCC" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/mattkretz/vir-simd/actions/workflows/Clang.yml"><img src="https://github.com/mattkretz/vir-simd/actions/workflows/Clang.yml/badge.svg" alt="Clang" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/mattkretz/vir-simd/actions/workflows/MSVC.yml"><img src="https://github.com/mattkretz/vir-simd/actions/workflows/MSVC.yml/badge.svg" alt="MSVC" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/mattkretz/vir-simd/actions/workflows/Emscripten.yml"><img src="https://github.com/mattkretz/vir-simd/actions/workflows/Emscripten.yml/badge.svg" alt="Emscripten" style="pointer-events: none;" class="inline"/></a> <a href="https://doi.org/10.5281/zenodo.7789153"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.7789153.svg" alt="DOI" style="pointer-events: none;" class="inline"/></a> <a href="https://bestpractices.coreinfrastructure.org/projects/6916"><img src="https://bestpractices.coreinfrastructure.org/projects/6916/badge" alt="OpenSSF Best Practices" class="inline"/></a> <a href="https://github.com/mattkretz/vir-simd/actions/workflows/reuse.yml"><img src="https://github.com/mattkretz/vir-simd/actions/workflows/reuse.yml/badge.svg" alt="REUSE status" style="pointer-events: none;" class="inline"/></a> <a href="https://fair-software.eu"><img src="https://img.shields.io/badge/fair--software.eu-%E2%97%8F%20%20%E2%97%8F%20%20%E2%97%8F%20%20%E2%97%8F%20%20%E2%97%8F-green" alt="fair-software.eu" class="inline"/></a></p>
<p>This project aims to provide a fallback std::experimental::simd (Parallelism TS 2) implementation with additional features. Not every user can rely on GCC 11+ and its standard library to be present on all target systems. Therefore, the header <code><a class="el" href="simd_8h_source.html">vir/simd.h</a></code> provides a fallback implementation of the TS specification that only implements the <code>scalar</code> and <code>fixed_size&lt;N&gt;</code> ABI tags. Thus, your code can still compile and run correctly, even if it is missing the performance gains a proper implementation provides.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Table of Contents</h1>
<ul>
<li>Installation</li>
<li>Usage</li>
<li>Options</li>
<li>Additional Features<ul>
<li>Simple iota `simd` constants</li>
<li>Making `simd` conversions more convenient</li>
<li>Permutations</li>
<li>SIMD execution policy<ul>
<li>Usable algorithms</li>
<li>Example</li>
<li>Execution policy modifiers</li>
</ul>
</li>
<li>Bitwise operators for floating-point `simd`</li>
<li>Conversion between `std::bitset` and `simd_mask`</li>
<li>vir::simd_resize and vir::simd_size_cast</li>
<li>vir::simd_bit_cast</li>
<li>Concepts</li>
<li>simdize type transformation</li>
<li>Benchmark support functions</li>
<li>`constexpr_wrapper`: function arguments as constant expressions<ul>
<li>Example</li>
</ul>
</li>
<li>Testing for the version of the vir::stdx::simd (vir-simd) library<ul>
<li>Semantics of version numbers</li>
</ul>
</li>
<li>Debugging</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md25"></a>
Installation</h1>
<p>This is a header-only library. Installation is a simple copy of the headers to wherever you want them. Per default <code>make install</code> copies the headers into <code>/usr/local/include/vir/</code>.</p>
<p>Examples: </p><div class="fragment"><div class="line"># installs to $HOME/.local/include/vir</div>
<div class="line">make install prefix=~/.local</div>
<div class="line"> </div>
<div class="line"># installs to $HOME/src/myproject/3rdparty/vir</div>
<div class="line">make install includedir=~/src/myproject/3rdparty</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md26"></a>
Usage</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/simd.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>stdx = vir::stdx;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>floatv = stdx::native_simd&lt;float&gt;;</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>The <code><a class="el" href="simd_8h_source.html">vir/simd.h</a></code> header will include <code>&lt;experimental/simd&gt;</code> if it is available, so you don't have to add any buildsystem support. It should just work.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Options</h1>
<ul>
<li><code>VIR_SIMD_TS_DROPIN</code>: Define the macro <code>VIR_SIMD_TS_DROPIN</code> before including <code>&lt;<a class="el" href="simd_8h_source.html">vir/simd.h</a>&gt;</code> to define everything in the namespace specified in the Parallelism TS 2 (namely <code>std::experimental::parallelism_v2</code>).</li>
<li><code>VIR_DISABLE_STDX_SIMD</code>: Do not include <code>&lt;experimental/simd&gt;</code> even if it is available. This allows compiling your code with the <code>&lt;<a class="el" href="simd_8h_source.html">vir/simd.h</a>&gt;</code> implementation unconditionally. This is useful for testing.</li>
</ul>
<h1><a class="anchor" id="autotoc_md28"></a>
Additional Features</h1>
<p>The TS curiously forgot to add <code>simd_cast</code> and <code>static_simd_cast</code> overloads for <code>simd_mask</code>. With <code>vir::stdx::(static_)simd_cast</code>, casts will also work for <code>simd_mask</code>. This does not require any additional includes.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Simple iota <code>simd</code> constants</h2>
<p><em>Requires Concepts (C++20).</em></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/simd_iota.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> a = vir::iota_v&lt;stdx::simd&lt;float&gt;&gt; * 3; <span class="comment">// 0, 3, 6, 9, ...</span></div>
</div><!-- fragment --><p>The variable template <code>vir::iota_v&lt;T&gt;</code> can be instantiated with arithmetic types, array types (<code>std::array</code> and C-arrays), and <code>simd</code> types. In all cases, the elements of the variable will be initialized to <code>0, 1, 2, 3, 4, ...</code>, depending on the number of elements in <code>T</code>. For arithmetic types <code>vir::iota_v&lt;T&gt;</code> is always just <code>0</code>.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Making <code>simd</code> conversions more convenient</h2>
<p><em>Requires Concepts (C++20).</em></p>
<p>The TS is way too strict about conversions, requiring verbose <code>std::experimental::static_simd_cast&lt;T&gt;(x)</code> instead of a concise <code>T(x)</code> or <code>static_cast&lt;T&gt;(x)</code>. (<code>std::simd</code> in C++26 will fix this.)</p>
<p><code>vir::cvt(x)</code> provides a tool to make <code>x</code> implicitly convertible into whatever the expression wants in order to be well-formed. This only works, if there is an unambiguous type that is required.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/simd_cvt.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>floatv = stdx::native_simd&lt;float&gt;;</div>
<div class="line"><span class="keyword">using </span>intv = stdx::rebind_simd_t&lt;int, floatv&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f(intv x) {</div>
<div class="line">  <span class="keyword">using </span>vir::cvt;</div>
<div class="line">  <span class="comment">// the floatv constructor and intv assignment operator clearly determine the</span></div>
<div class="line">  <span class="comment">// destination type:</span></div>
<div class="line">  x = cvt(10 * sin(floatv(cvt(x))));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// without vir::cvt, one would have write:</span></div>
<div class="line">  x = stdx::static_simd_cast&lt;intv&gt;(10 * sin(stdx::static_simd_cast&lt;floatv&gt;(x)));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// probably don&#39;t do this too often:</span></div>
<div class="line">  <span class="keyword">auto</span> y = cvt(x); <span class="comment">// y is a const-ref to x, but so much more convertible</span></div>
<div class="line">                   <span class="comment">// y is of type cvt&lt;intv&gt;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that <code>vir::cvt</code> also works for <code>simd_mask</code> and non-<code>simd</code> types. Thus, <code>cvt</code> becomes an important building block for writing "`simd`-generic" code (i.e. well-formed for <code>T</code> and <code>simd&lt;T&gt;</code>).</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Permutations (<a href="https://wg21.link/P2664">paper</a>)</h2>
<p><em>Requires Concepts (C++20).</em></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simd__permute_8h.html">vir/simd_permute.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// v = {0, 1, 2, 3} -&gt; {1, 0, 3, 2}</span></div>
<div class="line"><a class="code hl_function" href="namespacevir.html#aa540744e769ef0843bf2c318d3f24f2c">vir::simd_permute</a>(v, <a class="code hl_variable" href="namespacevir_1_1simd__permutations.html#a3ab35e5cf34b6a6d774d84f1a9bd292c">vir::simd_permutations::swap_neighbors</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// v = {1, 2, 3, 4} -&gt; {2, 2, 2, 2}</span></div>
<div class="line"><a class="code hl_function" href="namespacevir.html#aa540744e769ef0843bf2c318d3f24f2c">vir::simd_permute</a>(v, [](<span class="keywordtype">unsigned</span>) { <span class="keywordflow">return</span> 1; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// v = {1, 2, 3, 4} -&gt; {3, 3, 3, 3}</span></div>
<div class="line"><a class="code hl_function" href="namespacevir.html#aa540744e769ef0843bf2c318d3f24f2c">vir::simd_permute</a>(v, [](<span class="keywordtype">unsigned</span>) { <span class="keywordflow">return</span> -2; });</div>
<div class="ttc" id="anamespacevir_1_1simd__permutations_html_a3ab35e5cf34b6a6d774d84f1a9bd292c"><div class="ttname"><a href="namespacevir_1_1simd__permutations.html#a3ab35e5cf34b6a6d774d84f1a9bd292c">vir::simd_permutations::swap_neighbors</a></div><div class="ttdeci">constexpr SwapNeighbors&lt; N &gt; swap_neighbors</div><div class="ttdoc">Swaps N neighboring elements.</div><div class="ttdef"><b>Definition</b> simd_permute.h:109</div></div>
<div class="ttc" id="anamespacevir_html_aa540744e769ef0843bf2c318d3f24f2c"><div class="ttname"><a href="namespacevir.html#aa540744e769ef0843bf2c318d3f24f2c">vir::simd_permute</a></div><div class="ttdeci">constexpr stdx::resize_simd_t&lt; N==0 ? V::size() :N, V &gt; simd_permute(V const &amp;v, F const idx_perm) noexcept</div><div class="ttdoc">Permute the elements of v using the index permutation function idx_perm.</div><div class="ttdef"><b>Definition</b> simd_permute.h:180</div></div>
<div class="ttc" id="asimd__permute_8h_html"><div class="ttname"><a href="simd__permute_8h.html">simd_permute.h</a></div><div class="ttdoc">Permutation functions for the Parallelism TS 2 simd types.</div></div>
</div><!-- fragment --><p>The following permutations are pre-defined:</p>
<ul>
<li><code><a class="el" href="namespacevir_1_1simd__permutations.html#ac83176a07b5522f2c71513750f67c7fd" title="Copies even elements into odd elements.">vir::simd_permutations::duplicate_even</a></code>: copy values at even indices to neighboring odd position</li>
<li><code><a class="el" href="namespacevir_1_1simd__permutations.html#a409b895da2055d2865a0c69a7942ad48" title="Copies odd elements into even elements.">vir::simd_permutations::duplicate_odd</a></code>: copy values at odd indices to neighboring even position</li>
<li><code><a class="el" href="namespacevir_1_1simd__permutations.html#a3ab35e5cf34b6a6d774d84f1a9bd292c" title="Swaps N neighboring elements.">vir::simd_permutations::swap_neighbors</a>&lt;N&gt;</code>: swap <code>N</code> consecutive values with the following <code>N</code> consecutive values</li>
<li><code><a class="el" href="namespacevir_1_1simd__permutations.html#a7dcc2486767f70ad9876b5db78abbbcd" title="Copy element at index Position into all elements.">vir::simd_permutations::broadcast</a>&lt;Idx&gt;</code>: copy the value at index <code>Idx</code> to all other values</li>
<li><code><a class="el" href="namespacevir_1_1simd__permutations.html#ac99c012fddb652eca41ce99a4ab523a5" title="Copy the first element into all elements.">vir::simd_permutations::broadcast_first</a></code>: alias for <code>broadcast&lt;0&gt;</code></li>
<li><code><a class="el" href="namespacevir_1_1simd__permutations.html#a6a29e3c5551cf7a91a0200c718199f37" title="Copy the last element into all elements.">vir::simd_permutations::broadcast_last</a></code>: alias for <code>broadcast&lt;-1&gt;</code></li>
<li><code><a class="el" href="namespacevir_1_1simd__permutations.html#a1467669ebde9c7d3bf25fc243cd09d78" title="Reverse the elements.">vir::simd_permutations::reverse</a></code>: reverse the order of all values</li>
<li><code><a class="el" href="namespacevir_1_1simd__permutations.html#afbc110b32c8808fd333b22e8c66ea8bc" title="Rotate the elements by Offset.">vir::simd_permutations::rotate</a>&lt;Offset&gt;</code>: positive <code>Offset</code> rotates values to the left, negative <code>Offset</code> rotates values to the right (i.e. <code>rotate&lt;Offset&gt;</code> moves values from index <code>(i + Offset) % size</code> to <code>i</code>)</li>
<li><code><a class="el" href="namespacevir_1_1simd__permutations.html#a55ace76216d09691b10f752e488a0534" title="Shift the elements by Offset.">vir::simd_permutations::shift</a>&lt;Offset&gt;</code>: positive <code>Offset</code> shifts values to the left, negative <code>Offset</code> shifts values to the right; shifting in zeros.</li>
</ul>
<p>A <code>vir::simd_permute(x, idx_perm)</code> overload, where <code>x</code> is of <em>vectorizable</em> type, is also included, facilitating generic code.</p>
<p>A special permutation <code><a class="el" href="namespacevir.html#ada2f846a460f70c3d0e76a32f2dc7c4b" title="Concatenate a, more..., shift by Offset, and return the first V::size() elements.">vir::simd_shift_in</a>&lt;N&gt;(x, ...)</code> shifts by N elements shifting in elements from additional <code>simd</code> objects passed via the pack. Example: </p><div class="fragment"><div class="line"><span class="comment">// v = {1, 2, 3, 4}, w = {5, 6, 7, 8} -&gt; {2, 3, 4, 5}</span></div>
<div class="line"><a class="code hl_function" href="namespacevir.html#ada2f846a460f70c3d0e76a32f2dc7c4b">vir::simd_shift_in&lt;1&gt;</a>(v, w);</div>
<div class="ttc" id="anamespacevir_html_ada2f846a460f70c3d0e76a32f2dc7c4b"><div class="ttname"><a href="namespacevir.html#ada2f846a460f70c3d0e76a32f2dc7c4b">vir::simd_shift_in</a></div><div class="ttdeci">constexpr V simd_shift_in(V const &amp;a, std::convertible_to&lt; V &gt; auto const &amp;... more) noexcept</div><div class="ttdoc">Concatenate a, more..., shift by Offset, and return the first V::size() elements.</div><div class="ttdef"><b>Definition</b> simd_permute.h:313</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
SIMD execution policy (<a href="https://wg21.link/P0350">P0350</a>)</h2>
<p><em>Requires Concepts (C++20).</em></p>
<p>Adds an execution policy <code><a class="el" href="namespacevir_1_1execution.html#a1b09ad902aac3b1d0f900f35f9b90f5b" title="SIMD execution policy.">vir::execution::simd</a></code>. The execution policy can be used with the algorithms implemented in the <code>vir</code> namespace. These algorithms are additionally overloaded in the <code>std</code> namespace.</p>
<p>At this point, the implementation of the execution policy requires contiguous ranges / iterators.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
Usable algorithms</h3>
<ul>
<li><code><a class="elRef" href="https://en.cppreference.com/w/cpp/algorithm/for_each.html">std::for_each</a></code> / <code><a class="el" href="group__vir__for__each.html#ga83ae63e931a27703c0521b6e43df8499" title="Iterate over the given range (iterator overload).">vir::for_each</a></code></li>
<li><code><a class="elRef" href="https://en.cppreference.com/w/cpp/algorithm/count_if.html">std::count_if</a></code> / <code><a class="el" href="group__vir__count__if.html#ga07021695db7f024397c18cb0e4aba81b" title="Count the elements in the input range matching pred (iterator overload)">vir::count_if</a></code></li>
<li><code><a class="elRef" href="https://en.cppreference.com/w/cpp/algorithm/transform.html">std::transform</a></code> / <code><a class="el" href="group__vir__transform.html#ga4a9d7aa55f0fff0fa4b61dae30810b43" title="Unary transform (iterator overload)">vir::transform</a></code></li>
<li><code><a class="elRef" href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce.html">std::transform_reduce</a></code> / <code><a class="el" href="group__vir__transform__reduce.html#ga8461aa9e00c7c45cf990b67427ab26d1" title="Inner product (iterator overload)">vir::transform_reduce</a></code></li>
<li><code><a class="elRef" href="https://en.cppreference.com/w/cpp/algorithm/reduce.html">std::reduce</a></code> / <code><a class="el" href="group__vir__reduce.html#gae13f6db1d38dd5fcefd45d3f9363b83c" title="Sum the given range (iterator overload)">vir::reduce</a></code></li>
</ul>
<h3><a class="anchor" id="autotoc_md34"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simd__execution_8h.html">vir/simd_execution.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> increment_all(std::vector&lt;float&gt; data) {</div>
<div class="line">  <a class="code hl_functionRef" href="https://en.cppreference.com/w/cpp/algorithm/for_each.html">std::for_each</a>(<a class="code hl_variable" href="namespacevir_1_1execution.html#a1b09ad902aac3b1d0f900f35f9b90f5b">vir::execution::simd</a>, data.begin(), data.end(),</div>
<div class="line">    [](<span class="keyword">auto</span>&amp; v) {</div>
<div class="line">      v += 1.f;</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> increment_all(std::vector&lt;float&gt; data) {</div>
<div class="line">  <a class="code hl_function" href="group__vir__for__each.html#ga83ae63e931a27703c0521b6e43df8499">vir::for_each</a>(<a class="code hl_variable" href="namespacevir_1_1execution.html#a1b09ad902aac3b1d0f900f35f9b90f5b">vir::execution::simd</a>, data,</div>
<div class="line">    [](<span class="keyword">auto</span>&amp; v) {</div>
<div class="line">      v += 1.f;</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="ttc" id="afor_each_html"><div class="ttname"><a href="https://en.cppreference.com/w/cpp/algorithm/for_each.html">std::for_each</a></div><div class="ttdeci">for_each</div></div>
<div class="ttc" id="agroup__vir__for__each_html_ga83ae63e931a27703c0521b6e43df8499"><div class="ttname"><a href="group__vir__for__each.html#ga83ae63e931a27703c0521b6e43df8499">vir::for_each</a></div><div class="ttdeci">constexpr void for_each(ExecutionPolicy pol, It first, It last, F &amp;&amp;fun)</div><div class="ttdoc">Iterate over the given range (iterator overload).</div><div class="ttdef"><b>Definition</b> simd_execution.h:1113</div></div>
<div class="ttc" id="anamespacevir_1_1execution_html_a1b09ad902aac3b1d0f900f35f9b90f5b"><div class="ttname"><a href="namespacevir_1_1execution.html#a1b09ad902aac3b1d0f900f35f9b90f5b">vir::execution::simd</a></div><div class="ttdeci">constexpr simd_policy simd</div><div class="ttdoc">SIMD execution policy.</div><div class="ttdef"><b>Definition</b> simd_execution.h:528</div></div>
<div class="ttc" id="asimd__execution_8h_html"><div class="ttname"><a href="simd__execution_8h.html">simd_execution.h</a></div><div class="ttdoc">SIMD execution policy for standard algorithms.</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md35"></a>
Execution policy modifiers</h3>
<p>The <code><a class="el" href="namespacevir_1_1execution.html#a1b09ad902aac3b1d0f900f35f9b90f5b" title="SIMD execution policy.">vir::execution::simd</a></code> execution policy supports a few settings modifying its behavior:</p>
<ul>
<li><code>vir::execution::simd.prefer_size&lt;N&gt;()</code>: Start with chunking the range into parts of <code>N</code> elements, calling the user-supplied function(s) with objects of type <code>resize_simd_t&lt;N, simd&lt;T&gt;&gt;</code>.</li>
<li><code>vir::execution::simd.unroll_by&lt;M&gt;()</code>: Iterate over the range in chunks of <code>simd::size() * M</code> instead of just <code>simd::size()</code>. The algorithm will execute <code>M</code> loads (or stores) together before/after calling the user-supplied function(s). The user-supplied function may be called with <code>M</code> <code>simd</code> objects instead of one <code>simd</code> object. Note that prologue and epilogue will typically still call the user-supplied function with a single <code>simd</code> object. Algorithms like <code><a class="elRef" href="https://en.cppreference.com/w/cpp/algorithm/count_if.html">std::count_if</a></code> require a return value from the user-supplied function and therefore still call the function with a single <code>simd</code> (to avoid the need for returning an <code>array</code> or <code>tuple</code> of <code>simd_mask</code>). Such algorithms will still make use of unrolling inside their implementation.</li>
<li><code>vir::execution::simd.assume_matching_size()</code>: Add a precondition to the algorithm, that the given range size is a multiple of the SIMD width (but not the SIMD width multiplied by the above unroll factor). This modifier is only valid without prologue (the following two modifiers). The algorithm consequently does not implement an epilogue and all given callables are called with a single simd type (same width and ABI tag). This can reduce code size significantly.</li>
<li><code>vir::execution::simd.prefer_aligned()</code>: Unconditionally iterate using smaller chunks, until the main iteration can load (and store) chunks from/to aligned addresses. This can be more efficient if the range is large, avoiding cache-line splits. (e.g. with AVX-512, unaligned iteration leads to cache-line splits on every iteration; with AVX on every second iteration)</li>
<li><code>vir::execution::simd.auto_prologue()</code> (still testing its viability, may be removed): Determine from run-time information (i.e. add a branch) whether a prologue for alignment of the main chunked iteration might be more efficient.</li>
</ul>
<h2><a class="anchor" id="autotoc_md36"></a>
Bitwise operators for floating-point <code>simd</code></h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/simd_float_ops.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>vir::simd_float_ops;</div>
</div><!-- fragment --><p> Then the <code>&amp;</code>, <code>|</code>, and <code>^</code> binary operators can be used with objects of type <code>simd&lt;</code>floating-point<code>, A&gt;</code>.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Conversion between <code>std::bitset</code> and <code>simd_mask</code></h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/simd_bitset.h&gt;</span></div>
<div class="line"> </div>
<div class="line">vir::stdx::simd_mask&lt;int&gt; k;</div>
<div class="line">std::bitset b = vir::to_bitset(k);</div>
<div class="line">vir::stdx::simd_mask k2 = vir::to_simd_mask&lt;float&gt;;</div>
</div><!-- fragment --><p>There are two overloads of <code>vir::to_simd_mask</code>: </p><div class="fragment"><div class="line">to_simd_mask&lt;T, A&gt;(bitset&lt;simd_size_v&lt;T, A&gt;&gt;)</div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line">to_simd_mask&lt;T, N&gt;(bitset&lt;N&gt;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md38"></a>
vir::simd_resize and vir::simd_size_cast</h2>
<p>The header </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/simd_resize.h&gt;</span></div>
</div><!-- fragment --><p> declares the functions</p>
<ul>
<li><code>vir::simd_resize&lt;N&gt;(simd)</code>,</li>
<li><code>vir::simd_resize&lt;N&gt;(simd_mask)</code>,</li>
<li><code>vir::simd_size_cast&lt;V&gt;(simd)</code>, and</li>
<li><code>vir::simd_size_cast&lt;M&gt;(simd_mask)</code>.</li>
</ul>
<p>These functions can resize a given <code>simd</code> or <code>simd_mask</code> object. If the return type requires more elements than the input parameter, the new elements are default-initialized and appended at the end. Both functions do not allow a change of the <code>value_type</code>. However, implicit conversions can happen on parameter passing to <code>simd_size_cast</code>.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
vir::simd_bit_cast</h2>
<p>The header </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/simd_bit.h&gt;</span></div>
</div><!-- fragment --><p> declares the function <code>vir::simd_bit_cast&lt;To&gt;(from)</code>. This function serves the same purpose as <code>std::bit_cast</code> but additionally works in cases where a <code>simd</code> type is not trivially copyable.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Concepts</h2>
<p><em>Requires Concepts (C++20).</em></p>
<p>The header </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simd__concepts_8h.html">vir/simd_concepts.h</a>&gt;</span></div>
<div class="ttc" id="asimd__concepts_8h_html"><div class="ttname"><a href="simd__concepts_8h.html">simd_concepts.h</a></div><div class="ttdoc">C++20 concepts extending the Parallelism TS 2 (which is limited to C++17).</div></div>
</div><!-- fragment --><p> defines the following concepts:</p>
<ul>
<li><code><a class="el" href="conceptvir_1_1arithmetic.html" title="This concept matches the core language defintion of an arithmetic type.">vir::arithmetic</a>&lt;T&gt;</code>: What <code>std::arithmetic&lt;T&gt;</code> should be: satisfied if <code>T</code> is an arithmetic type (as specified by the C++ core language).</li>
<li><code><a class="el" href="conceptvir_1_1vectorizable.html" title="Satisfied for all arithmetic types except bool.">vir::vectorizable</a>&lt;T&gt;</code>: Satisfied if <code>T</code> is a valid element type for <code>stdx::simd</code> and <code>stdx::simd_mask</code>.</li>
<li><code><a class="el" href="conceptvir_1_1simd__abi__tag.html" title="Satisfied if T is a SIMD ABI tag.">vir::simd_abi_tag</a>&lt;T&gt;</code>: Satisfied if <code>T</code> is a valid ABI tag for <code>stdx::simd</code> and <code>stdx::simd_mask</code>.</li>
<li><code><a class="el" href="conceptvir_1_1any__simd.html" title="Satisfied if V is a (valid) specialization of simd&lt;T, Abi&gt;.">vir::any_simd</a>&lt;V&gt;</code>: Satisfied if <code>V</code> is a specialization of <code>stdx::simd&lt;T, Abi&gt;</code> and the types <code>T</code> and <code>Abi</code> satisfy <code><a class="el" href="conceptvir_1_1vectorizable.html" title="Satisfied for all arithmetic types except bool.">vir::vectorizable</a>&lt;T&gt;</code> and <code><a class="el" href="conceptvir_1_1simd__abi__tag.html" title="Satisfied if T is a SIMD ABI tag.">vir::simd_abi_tag</a>&lt;Abi&gt;</code>.</li>
<li><code><a class="el" href="conceptvir_1_1any__simd__mask.html" title="Satisfied if V is a (valid) specialization of simd_mask&lt;T, Abi&gt;.">vir::any_simd_mask</a>&lt;V&gt;</code>: Analogue to <code><a class="el" href="conceptvir_1_1any__simd.html" title="Satisfied if V is a (valid) specialization of simd&lt;T, Abi&gt;.">vir::any_simd</a>&lt;V&gt;</code> for <code>stdx::simd_mask</code> instead of <code>stdx::simd</code>.</li>
<li><code><a class="el" href="conceptvir_1_1typed__simd.html" title="Satisfied if V is a simd&lt;T, Abi&gt; with arbitrary but valid ABI tag Abi.">vir::typed_simd</a>&lt;V, T&gt;</code>: Satisfied if <code><a class="el" href="conceptvir_1_1any__simd.html" title="Satisfied if V is a (valid) specialization of simd&lt;T, Abi&gt;.">vir::any_simd</a>&lt;V&gt;</code> and <code>T</code> is the element type of <code>V</code>.</li>
<li><code><a class="el" href="conceptvir_1_1sized__simd.html" title="Satisfied if V is a simd with the given size Width.">vir::sized_simd</a>&lt;V, Width&gt;</code>: Satisfied if <code><a class="el" href="conceptvir_1_1any__simd.html" title="Satisfied if V is a (valid) specialization of simd&lt;T, Abi&gt;.">vir::any_simd</a>&lt;V&gt;</code> and <code>Width</code> is the width of <code>V</code>.</li>
<li><code><a class="el" href="conceptvir_1_1sized__simd__mask.html" title="Satisfied if V is a simd_mask with the given size Width.">vir::sized_simd_mask</a>&lt;V, Width&gt;</code>: Analogue to <code><a class="el" href="conceptvir_1_1sized__simd.html" title="Satisfied if V is a simd with the given size Width.">vir::sized_simd</a>&lt;V, Width&gt;</code> for <code>stdx::simd_mask</code> instead of <code>stdx::simd</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md41"></a>
simdize type transformation</h2>
<p><em>Requires Concepts (C++20).</em></p>
<p>:warning: consider this interface under :construction:</p>
<p>The header </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simdize_8h.html">vir/simdize.h</a>&gt;</span></div>
<div class="ttc" id="asimdize_8h_html"><div class="ttname"><a href="simdize_8h.html">simdize.h</a></div><div class="ttdoc">Provides a type transformation for turning scalar user-defined types into a simd types.</div></div>
</div><!-- fragment --><p> defines the following types and constants:</p>
<ul>
<li><p class="startli"><code><a class="el" href="namespacevir.html#aa9157ef3f9863e8dc719bcc2166baf50" title="Apply a type transformation to a scalar type to produce a data-parallel type.">vir::simdize</a>&lt;T, N&gt;</code>: <code>N</code> is optional. Type alias for a <code>simd</code> or <code>vir::simd_tuple</code> type determined from the type <code>T</code>.</p><ul>
<li>If <code><a class="el" href="conceptvir_1_1vectorizable.html" title="Satisfied for all arithmetic types except bool.">vir::vectorizable</a>&lt;T&gt;</code> is satisfied, then <code>stdx::simd&lt;T, Abi&gt;</code> is produced. <code>Abi</code> is determined from <code>N</code> and will be <code>simd_abi::native&lt;T&gt;</code> if <code>N</code> was omitted.</li>
<li>If <code>T</code> is a <code>std::tuple</code> or aggregate that can be reflected, then a specialization of <code>vir::simd_tuple</code> is produced. If <code>T</code> is a template specialization (without NTTPs), the metafunction tries vectorization via applying <code>simdize</code> to all template arguments. If this doesn't yield the same data structure layout as member-only vectorization, then the type behaves similar to a <code>std::tuple</code> with additional API to make the type similar to <code>stdx::simd</code> (see below). This specialization will be derived from <code>std::tuple</code> and the tuple elements will either be <code>vir::simd_tuple</code> or <code>stdx::simd</code> types. <code><a class="el" href="namespacevir.html#aa9157ef3f9863e8dc719bcc2166baf50" title="Apply a type transformation to a scalar type to produce a data-parallel type.">vir::simdize</a></code> is applied recursively to the <code>std::tuple</code>/aggregate data members.</li>
<li>Otherwise, <code>T</code> cannot be simdized (e.g. void, no data members, <code>std::tuple&lt;&gt;</code>) then no transformation is applied and <code>simdize&lt;T&gt;</code> is an alias for <code>T</code>.</li>
<li>If <code>N</code> was omitted, the resulting width of <em>all</em> <code>simd</code> types in the resulting type will match the largest <code>native_simd</code> width.</li>
</ul>
<p class="startli">Example: <code><a class="el" href="namespacevir.html#aa9157ef3f9863e8dc719bcc2166baf50" title="Apply a type transformation to a scalar type to produce a data-parallel type.">vir::simdize</a>&lt;std::tuple&lt;double, short&gt;&gt;</code> produces a tuple with the element types <code>stdx::rebind_simd_t&lt;double, stdx::native_simd&lt;short&gt;&gt;</code> and <code>stdx::native_simd&lt;short&gt;</code>.</p>
</li>
<li><code>vir::simd_tuple&lt;reflectable_struct T, size_t N&gt;</code>: Don't use this class template directly. Let <code><a class="el" href="namespacevir.html#aa9157ef3f9863e8dc719bcc2166baf50" title="Apply a type transformation to a scalar type to produce a data-parallel type.">vir::simdize</a></code> instantiate specializations of this class template. <code>vir::simd_tuple</code> mostly behaves like a <code>std::tuple</code> and adds the following interface on top of <code>std::tuple</code>:<ul>
<li><code>value_type</code></li>
<li><code>mask_type</code></li>
<li><code>size</code></li>
<li>tuple-like constructors</li>
<li>broadcast and/or conversion constructors</li>
<li>load constructor</li>
<li><code>as_tuple()</code>: Returns the data members as a <code>std::tuple</code>.</li>
<li><code>operator[](size_t)</code>: Copy of a single <code>T</code> stored in the <code>simd_tuple</code>. This is not a cheap operation because there are no <code>T</code> objects stored in the <code>simd_tuple</code>.</li>
<li><code>copy_from(std::contiguous_iterator)</code>: :construction: unoptimized load from a contiguous array of struct (e.g. <code>std::vector&lt;T&gt;</code>).</li>
<li><code>copy_to(std::contiguous_iterator)</code>: :construction: unoptimized store to a contiguous array of struct.</li>
</ul>
</li>
<li><code>vir::simd_tuple&lt;vectorizable_struct_template T, size_t N&gt;</code>: TODO</li>
<li><code><a class="el" href="namespacevir.html#a9a2a7e508973d3fb2864ec6253f42520">vir::get</a>&lt;I&gt;(simd_tuple)</code>: Access to the <code>I</code>-th data member (a <code>simd</code>).</li>
<li><code><a class="el" href="structvir_1_1simdize__size.html">vir::simdize_size</a>&lt;T&gt;</code>, <code><a class="el" href="namespacevir.html#a02ae14af201b7a03cb19876c76513b57" title="Inline variable for the simdize_size trait.">vir::simdize_size_v</a>&lt;T&gt;</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md42"></a>
Benchmark support functions</h2>
<p><em>Requires Concepts (C++20) and GNU compatible inline-asm.</em></p>
<p>The header </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/simd_benchmarking.h&gt;</span></div>
</div><!-- fragment --><p> defines the following functions:</p>
<ul>
<li><code>vir::fake_modify(...)</code>: Let the compiler assume that all arguments passed to this functions are modified. This inhibits constant propagation, hoisting of code sections, and dead-code elimination.</li>
<li><code>vir::fake_read(...)</code>: Let the compiler assume that all arguments passed to this function are read (in the cheapest manner). This inhibits dead-code elimination leading up to the results passed to this function.</li>
</ul>
<h2><a class="anchor" id="autotoc_md43"></a>
<code>constexpr_wrapper</code>: function arguments as constant expressions</h2>
<p>The header </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/constexpr_wrapper.h&gt;</span></div>
</div><!-- fragment --><p> defines the following tools:</p>
<ul>
<li><code>vir::constexpr_value</code> (concept): Satisfied by any type with a static <code>::value</code> member that can be used in a constant expression.</li>
<li><code><a class="el" href="structvir_1_1constexpr__wrapper.html">vir::constexpr_wrapper</a>&lt;auto&gt;</code> (class template): A type storing the value of its NTTP (non-type template parameter) and overloading all operators to return another <code>constexpr_wrapper</code>. <code>constexpr_wrapper</code> objects are implicitly convertible to their value type (a <code>constexpr_wrapper</code> automatically unwraps its constant expression).</li>
<li><code>vir::cw&lt;auto&gt;</code> (variable template): Shorthand for producing <code>constexpr_wrapper</code> objects with the given value.</li>
<li><code>vir::literals</code> (namespace with <code>_cw</code> UDL): Shorthand for producing <code>constexpr_wrapper</code> objects of the integer literal in front of the <code>_cw</code> suffix. The type will be deduced automatically from the value of the literal to be the smallest signed integral type, or if the value is larger, <code>unsigned long long</code>. If the value is too large for an <code>unsigned long long</code>, the program is ill-formed.</li>
</ul>
<p><code>constexpr_wrapper</code> may appear unrelated to <code>simd</code>. However, it is an important tool used in many places in the implementation and on interfaces of vir-simd tools. <code><a class="el" href="structvir_1_1constexpr__wrapper.html">vir::constexpr_wrapper</a></code> is very similar to <code>std::integral_constant</code>, which is used in the <code>simd</code> TS interface for generator constructors.</p>
<h3><a class="anchor" id="autotoc_md44"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vir/constexpr_wrapper.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> f(vir::constexpr_value <span class="keyword">auto</span> N)</div>
<div class="line">{</div>
<div class="line">  std::array&lt;int, N&gt; x = {};</div>
<div class="line">  <span class="keywordflow">return</span> x;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::array a = f(vir::cw&lt;4&gt;); <span class="comment">// array&lt;int, 4&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>vir::literals;</div>
<div class="line"> </div>
<div class="line">std::array b = f(10_cw); <span class="comment">// array&lt;int, 10&gt;</span></div>
</div><!-- fragment --><p>This example cannot work with a signature <code>constexpr auto f(int n)</code> (or <code>consteval</code>) because <code>n</code> will never be considered a constant expression in the body of the function.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Testing for the version of the vir::stdx::simd (vir-simd) library</h2>
<p>The header </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simd__version_8h.html">vir/simd_version.h</a>&gt;</span></div>
<div class="ttc" id="asimd__version_8h_html"><div class="ttname"><a href="simd__version_8h.html">simd_version.h</a></div><div class="ttdoc">Version macros and version constant.</div></div>
</div><!-- fragment --><p> (which is also included from <code>&lt;<a class="el" href="simd_8h_source.html">vir/simd.h</a>&gt;</code>) defines the type and constant </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacevir.html">vir</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_struct" href="structvir_1_1simd__version__t.html">simd_version_t</a> { <span class="keywordtype">int</span> <a class="code hl_variable" href="structvir_1_1simd__version__t.html#a47eb0dfe1b553125399e4747856a7698">major</a>, <a class="code hl_variable" href="structvir_1_1simd__version__t.html#ac1ea92a002f597657ded88a989b1f176">minor</a>, <a class="code hl_variable" href="structvir_1_1simd__version__t.html#aef01e9c873063030d40a23ee68cb633c">patchlevel</a>; };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">constexpr</span> <a class="code hl_struct" href="structvir_1_1simd__version__t.html">simd_version_t</a> <a class="code hl_variable" href="namespacevir.html#a2e2ba1793421292d6466b3db33a1136e">simd_version</a>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacevir_html"><div class="ttname"><a href="namespacevir.html">vir</a></div><div class="ttdoc">This namespace collects libraries and tools authored by Matthias Kretz.</div><div class="ttdef"><b>Definition</b> constexpr_wrapper.h:21</div></div>
<div class="ttc" id="anamespacevir_html_a2e2ba1793421292d6466b3db33a1136e"><div class="ttname"><a href="namespacevir.html#a2e2ba1793421292d6466b3db33a1136e">vir::simd_version</a></div><div class="ttdeci">constexpr simd_version_t simd_version</div><div class="ttdoc">The current version.</div><div class="ttdef"><b>Definition</b> simd_version.h:114</div></div>
<div class="ttc" id="astructvir_1_1simd__version__t_html"><div class="ttname"><a href="structvir_1_1simd__version__t.html">vir::simd_version_t</a></div><div class="ttdoc">Represents the vir-simd version of major, minor, and patchlevel components.</div><div class="ttdef"><b>Definition</b> simd_version.h:56</div></div>
<div class="ttc" id="astructvir_1_1simd__version__t_html_a47eb0dfe1b553125399e4747856a7698"><div class="ttname"><a href="structvir_1_1simd__version__t.html#a47eb0dfe1b553125399e4747856a7698">vir::simd_version_t::major</a></div><div class="ttdeci">int major</div><div class="ttdoc">An increment of the major version number implies a breaking change.</div><div class="ttdef"><b>Definition</b> simd_version.h:58</div></div>
<div class="ttc" id="astructvir_1_1simd__version__t_html_ac1ea92a002f597657ded88a989b1f176"><div class="ttname"><a href="structvir_1_1simd__version__t.html#ac1ea92a002f597657ded88a989b1f176">vir::simd_version_t::minor</a></div><div class="ttdeci">int minor</div><div class="ttdoc">An increment of the minor version number implies new features without breaking changes.</div><div class="ttdef"><b>Definition</b> simd_version.h:60</div></div>
<div class="ttc" id="astructvir_1_1simd__version__t_html_aef01e9c873063030d40a23ee68cb633c"><div class="ttname"><a href="structvir_1_1simd__version__t.html#aef01e9c873063030d40a23ee68cb633c">vir::simd_version_t::patchlevel</a></div><div class="ttdeci">int patchlevel</div><div class="ttdoc">An increment of the patchlevel is used for bug fixes. Odd numbers indicate a development version.</div><div class="ttdef"><b>Definition</b> simd_version.h:62</div></div>
</div><!-- fragment --><p> in addition to the macros <code>VIR_SIMD_VERSION</code>, <code>VIR_SIMD_VERSION_MAJOR</code>, <code>VIR_SIMD_VERSION_MINOR</code>, and <code>VIR_SIMD_VERSION_PATCHLEVEL</code>.</p>
<p><code>simd_version_t</code> implements all comparison operators, allowing e.g. </p><div class="fragment"><div class="line"><span class="keyword">static_assert</span>(<a class="code hl_variable" href="namespacevir.html#a2e2ba1793421292d6466b3db33a1136e">vir::simd_version</a> &gt;= <a class="code hl_struct" href="structvir_1_1simd__version__t.html">vir::simd_version_t</a>{0,4,0});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md46"></a>
Semantics of version numbers</h3>
<ul>
<li>An increment of the major version number implies a breaking change.</li>
<li>An increment of the minor version number implies new features without breaking changes.</li>
<li>An increment of the patchlevel is used for bug fixes.</li>
<li>Odd patchlevel numbers indicate a development (not released) version.</li>
</ul>
<h1><a class="anchor" id="autotoc_md47"></a>
Debugging</h1>
<p>Compile with <code>-D _GLIBCXX_DEBUG_UB</code> to get runtime checks for undefined behavior in the <code>simd</code> implementation(s). Otherwise, <code>-fsanitize=undefined</code> without the macro definition will also find the problems, but without additional error message.</p>
<p>Preconditions in the vir::stdx::simd implementation and extensions are controlled via the <code>-D VIR_CHECK_PRECONDITIONS=N</code> macro, which defaults to <code>3</code>. Compile-time diagnostics are only possible if the compiler's optimizer can detect the precondition failure. If you get a bogus compile-time failure, you need to introduce the necessary assumption into your calling function, which is typically a missing precondition check in your function.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft"><b>Option</b>   </th><th class="markdownTableHeadCenter"><b>at compile-time</b>   </th><th class="markdownTableHeadCenter"><b>at run-time</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>-DVIR_CHECK_PRECONDITIONS=0</code>   </td><td class="markdownTableBodyCenter">warning   </td><td class="markdownTableBodyCenter">invoke UB/unreachable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>-DVIR_CHECK_PRECONDITIONS=1</code>   </td><td class="markdownTableBodyCenter">error   </td><td class="markdownTableBodyCenter">invoke UB/unreachable    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>-DVIR_CHECK_PRECONDITIONS=2</code>   </td><td class="markdownTableBodyCenter">warning   </td><td class="markdownTableBodyCenter">trap    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>-DVIR_CHECK_PRECONDITIONS=3</code>   </td><td class="markdownTableBodyCenter">error   </td><td class="markdownTableBodyCenter">trap    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>-DVIR_CHECK_PRECONDITIONS=4</code>   </td><td class="markdownTableBodyCenter">warning   </td><td class="markdownTableBodyCenter">print error and abort    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>-DVIR_CHECK_PRECONDITIONS=5</code>   </td><td class="markdownTableBodyCenter">error   </td><td class="markdownTableBodyCenter">print error and abort   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
